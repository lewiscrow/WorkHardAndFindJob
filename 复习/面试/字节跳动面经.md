## 字节跳动面经

### [字节跳动1-3面](https://www.nowcoder.com/discuss/427194)

#### 一面

1.抽象类和接口

网上有很多奇怪的答案，比如说“接口中只能有抽象方法”，这些说法过时了，1.8以后以我为准。 
区别有很多，比如说：
* 抽象类用 abstract class，接口用 interface；
* 抽象类中属性可以是任何修饰符修饰的，接口中属性只能是 public 或者没有修饰符；
* 抽象类中的方法可以是任意访问修饰符，接口中方法只能是 public static 或者 static；
* 抽象类可以有构造方法，接口不能有；
* 实现的话，抽象类依靠子类使用 extends 继承，接口则用 implements；
* 一个类最多只能继承一个类，但是可以实现多接口；
* 抽象类被继承时体现的是 is-a 关系，接口被实现时体现的是 can-do 关系。

2.成员变量和方法的区别

成员变量是属性，体现了对象有什么特性，成员方法是行为，体现了对象能干什么。

3.内部类

内部类有四种：成员内部类、静态内部类、方法内部类以及匿名内部类
[Java基础复习(四、三大特性) - 内部类](https://blog.csdn.net/kirito_lewis/article/details/105953550#innerclass)

4.基本数据类型，拆箱装箱

七种，byte、short、int、long、float、double、char。
拆箱装箱是因为他们的包装类型，可以运行下面代码：
```
int i = 3;
Integer j = i;
```
这是因为编译器自动将这段代码变成了调用`Integer.valueOf()`方法。还有`intValue()`方法的使用。

5.java的同步和并发

同步就是单线程操作，没啥好说的。
并发就是多线程操作，通过线程来完成多任务的操作。
创建线程的三种方式：1、继承`Thread`类；2、实现`Runnable`接口；3、实现`Callable`接口。
优缺点：
(1)、采用实现Runnable、Callable接口的方式创建多线程时，
优势是：
线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
劣势是：
编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。
(2)、使用继承Thread类的方式创建多线程时，
优势是：
编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
劣势是：
线程类已经继承了Thread类，所以不能再继承其他父类。
(3)、Runnable和Callable的区别
[1] Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。
[2] Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
[3] call方法可以抛出异常，run方法不可以。
[4] 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

6.HashMap的底层实现和扩容机制等

底层实现，bucket + linkedlist/红黑树
扩容机制：
当`size > threshold (该字段记录下一次扩容的大小，capacity * load factor)`时，调用 `resize()`方法，Map 容量乘以 2，以保证容量是 2 的幂次，然后将原来的节点放到新的 bucket 中。

7.GC 垃圾回收机制

如果是问垃圾回收策略的话，有以下三个：
(1)复制回收算法
此种方法通过依次扫描区域所有的可达对象，然后将其复制到另外一片区域保存起来，再将其现在正在使用的区域内存全部清空，此方法的优点在于方便快捷，只需要便利出所有的可达对象即可，而且不会出现碎片化内存。但是缺点也很明显，复制对象需要计算成本，此外需要准备一个额外相同Eden区域大小的内存空间，也是一笔巨大的开销。
(2)标记清除法
这种方法首先遍历整个区域中的对象，然后标记所有的可达对象，再将所有内存中未被标记的对象全部清除。主要缺点在于会产生大量的碎片内存。
(3)标记整理法
这种方法集上面两种算法的优点于一身，首先遍历整个空间对可达对象进行标记，然后再将所有可达对象整理到一起去，最后清除掉不可达的对象，达到GC回收清理内存的目的。（这个跟复制回收算法有区别？？？）

8.Java 编译后的字节码文件结构是怎样的？

（这谁记得住啊。。。）首先是 4 个字节的魔数(用于查看文件是否能运行，因为后缀名可以随便改)。2 个字节的次版本号，2 个字节的主版本号（版本号用于判别虚拟机是否可以运行当前版本，可以向下兼容）。2 个字节常量池计数值，（常量计数值 - 1）* （对应类型的大小）个字节的常量池大小，大小跟常量类型有关。然后是 2 个字节的访问标志（是类还是接口，是不是 public 类， 是不是 abstract 类型，有没有被声明成 final 等等）。2 个字节的类索引（确定全限定名）和 2 个字节的父类索引（父类的全限定名）。2 个字节的接口计数值，（接口数 * 2）个字节的接口。2个字节的字段计数值，（字段计数值 * 对应类型的大小）个字节的字段。2 个字节的方法计数值，（方法计数值 * 对应方法的大小）个字节的方法。

9.算法：每k个反转链表，leetcode原题。

这题在 LeetCode 中算 hard 的啊。。。
```
	public ListNode reverseKGroup(ListNode head, int k) {
	    ListNode dummy = new ListNode(0);
	    dummy.next = head;

	    ListNode pre = dummy;
	    ListNode end = dummy;

	    while (end.next != null) {
	        for (int i = 0; i < k && end != null; i++) end = end.next;
	        if (end == null) break;
	        ListNode start = pre.next;
	        ListNode next = end.next;
	        end.next = null;
	        pre.next = reverse(start);
	        start.next = next;
	        pre = start;

	        end = pre;
	    	}
	    return dummy.next;
	    }

	    private ListNode reverse(ListNode head) {
	    ListNode pre = null;
	    ListNode curr = head;
	    while (curr != null) {
	        ListNode next = curr.next;
	        curr.next = pre;
	        pre = curr;
	        curr = next;
	    }
	    return pre;
	}
```

#### 二面

1.计算机网络组成原理

OSI模型和TCP/IP模型以及两者的综合五层模型

2.计网

a.五层结构有哪几层？哪一层实现最麻烦？

物理层、数据链路层、网络层、传输层、应用层。应用层实现最麻烦，因为不同应用的协议

b.TCP 是干什么的？为什么有了 TCP 还需要 IP 等协议？TCP 可靠传输如何实现？三次握手?为什么需要三次？

TCP是传输层的协议，用于端到端的报文段的可靠传输。
IP协议是网络层的，用于网际互联，注重的层次不一样，因此需要IP这些协议。
通过三次握手构建稳定链接。三次握手四次拜拜。如节点A和节点B之间传输数据，三次握手分别是：1、节点A发送到节点B，表示节点A发送功能没问题；节点B收到数据后将结果发送到节点A，表示节点B发送功能和接收功能都没问题；节点A收到数据后将结果发送给节点B表示自己接收功能没问题

c.DNS 解析的过程，为什么目的是获得 IP 还要用 URL？直接用 IP 不好吗？根服务器在哪里？

(1)先找浏览器缓存中有没有，有则返回没有则下一步；
(2)再找系统缓存（Host文件）中有没有，有则返回没有则下一步；
(3)在路由器缓存中查找，有则返回没有则下一步；
(4)到互联网服务提供商DNS缓存中查找（电信、移动），有则返回没有则下一步；
(5)到根域名服务器的区域文件记录中查找，有则返回没有则将其管辖范围内顶级域名服务器IP告诉本地DNS服务器；
(6)顶级域名服务器查看区域文件记录，有则返回没有则将其管辖范围内主域名服务器的IP告诉本地DNS服务器；
(7)主域名服务器查找自己缓存，有则返回没有则进入下一级域名服务器查找，直到找到正确记录；
(8)本地域名服务器把返回的结果保存到缓存，并返回客户端。
之所以需要URL不用IP是因为IP不好记，URL比较好记。
根服务器分布在全球，一共为13台原有根+25台v6辅助根。中国有4台，一台主根和三台辅根。

d.HTTP 和 HTTPS，HTTPS 如何加密？

HTTP是超文本传输协议，用于Web浏览器和服务器之间传递消息，以明文方式交换数据，因此不安全。
HTTPS是安全套接字层超文本传输协议，在HTTP的基础上添加了SSL协议，依靠证书来验证服务器的身份，并提供了通信加密。

3.OS

a.磁盘空间空闲管理

[Linux磁盘空闲空间调度管理](https://blog.csdn.net/roger_ranger/article/details/77689709)

4.数据库

a.数据库索引是什么？为什么选择 B+ 树？

索引就是为了避免全表查找，利用特定列形成B+树从而加快搜索的速度。
选用B+树是因为稳定且好用。不用Hash数组是因为在分组、排序等操作时，复杂度会退化成O(n)，而B+树还是O(logn)。不用二叉查找树是因为B+树的范围查找比二叉查找树优秀，不需要中序回溯，并且改进后查询全部数据时不需要中序遍历而是直接用链表。
总的来说就是：
（1）适合磁盘存储，能够充分利用局部性原理，磁盘预读；
（2）树高度较小，能够存储大量数据（相对于二叉树而言）；
（3）索引本身占用的内存很小；
（4）能够很好的支持单点查询，范围查询，有序性查询。

5.算法：

a.给一个整数数组，找右边元素减左边元素的最大差值

LeetCode 股票题解：
```
	public int maxProfit(int[] prices) {
		int[] values = new int[prices.length-1];
		// 将每天的价格变成每天相比前一天的变化量
		for(int i=0;i<prices.length-1;i++) {
			values[i] = prices[i+1]-prices[i];
		}
		// 求最大子序列和
		int res = values[0];
		for(int i=1;i<values.length;i++) {
			values[i] += Math.max(values[i-1], 0);
			res = Math.max(res, values[i]);
		}
		return res>0?res:0;
    }
```
b.旋转数组
```
	public void rotate(int[] nums, int k) {
		int[] a = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            a[(i + k) % nums.length] = nums[i];
        }
        for (int i = 0; i < nums.length; i++) {
            nums[i] = a[i];
        }
    }
```

#### 三面

1.关于Linux和Android的了解？？？

2.代码环节

a.线程内部修改外部变量，外部变量用static和voaltile修饰时情况是怎么样的。去除这些关键字，如何实现变量一经修改，外部打印语句就可以马上打印新的值。

b.算法题：二进制反转

c.二叉树的前序遍历的Iterator

3.职业规划
（这个感觉讲的不是很清楚）

### [字节后端一二三面面经](https://www.nowcoder.com/discuss/415666?channel=666&source_id=subject)

#### 一面

1.Java 内存模型

线程私有的有程序计数器、虚拟机栈、本地方法栈，非线程私有的有堆、方法区（元空间）
具体内容看 [JVM 知识点整理](/Users/y1271752959m/Documents/WorkHardAndFindJob/复习/面试/JVM 知识点整理.md)

2.两个进程的变量的地址相同，他们之间的写操作又相互的影响吗？

没有影响。首先我们所说的进程的变量的地址，其实是逻辑地址，而不是真实的物理地址。逻辑地址由各自进程进行管理，因此在一台计算机上，可以有多个进行有相同的逻辑地址，但是他们在内存中的物理地址其实并不相同。

3.进程通信的方式

进程间通信主要有以下几种方式：
* 管道：
	* 只支持半双工通信
	* 只能在父子进程或者兄弟进程间使用
* FIFO：去除了管道只能在父子进程中使用的限制，常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据
* 消息队列：相比FIFO具有以下优点
	* 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
	* 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
	* 杜金城可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收
* 信号量：是一个计数器，用于为多个进程提供对共享数据对象的访问
* 共享存储：
	* 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC
	* 需要使用信号量来同步对共享存储的访问
	* 多个进程可以将同一个文件映射到他们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段
* 套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信。

4.关系型和非关系型数据库

关系型数据库是指采用了关系模型来组织数据的数据库，常见的有 Mysql、Oracle等
非关系型数据库是指不是关系模型的数据库，常采用键值对的形式，如 redis、MangoDB等

5.事务的特点

A（原子性）C（一致性）I（隔离性）D（持久性）

a.原子性和一致性的实现原理

emmmmm？是想问事务隔离级别和 MVCC 嘛？
[数据库内容总结](/Users/y1271752959m/Documents/WorkHardAndFindJob/复习/面试/数据库内容总结.md)

6.TCP 和 IP 为什么要四次挥手？

啊？应该是 TCP 为什么要四次挥手把。
第一次挥手，客户机向服务器发送断开连接的报文段；
第二次挥手，服务器向客户机发送确认断开连接的报文段，此时客户机无法再向服务器发送数据，但服务器还能像客户机发送；
第三次挥手，服务器向客户机发送断开连接的报文段；
第四次挥手，客户机向服务器发送确认报文段，并在计时器结束后进入连接关闭状态

a.Close_wait 状态是什么？

客户机在发起关闭连接后的第四次挥手时，客户机收到服务器发送的 FIN 报文段，然后客户机发出 ACK 并进入 time_wait 状态。在这个状态下，如果客户机发出的 ACK 丢失，那么由于 TCP 的重传机制，服务器会重发 FIN，此时客户机还能重发 ACK。如果没有这个状态，那么客户机直接释放连接后，如果发出的 ACK 丢失，等到客户机重新受到服务器发出的 FIN 时，就会发出 RST 包使得服务器以为有错误发生。在进入 time_wait 状态后，客户机仍要经过 2 个MSL值才能释放连接。

7.甲乙轮流射箭，两个人命中靶子的概率都是0.5，谁先射中谁就赢，问甲获胜的概率（答案：2/3）

8.算法题：给出一串数字，去掉 K 个数，问能形成的最小的数

#### 二面

1.Java HashMap

a.put 数据的过程

首先计算 key 的 hashcode，对于 String 来说，是 val[0] * 31^0 + val[1] * 31^1 + ... + val[i] * 31^i。
然后用该 hashcode 计算该键在数组中 bucket 的位置，计算方法为 hashcode ^ (hashcode >>> 16) & 数组长度
找到该 bucket 的节点，如果不存在节点，就直接 new 一个 Node 放上去就好了，如果存在节点，则判断这个节点上是红黑树还是链表，如果是链表，则遍历链表知道找到对应的 key进行赋值，或者没找到就新建一个节点。
节点修改之后，对修改次数和 map 大小进行 ++，并判断 map 大小是否超出阈值，超出阈值则 resize。

b.链表非常长会怎么样

不会非常长，到一定程度就会转化成红黑树了

c.什么情况下会转红黑树

超过一定的阈值，默认貌似是 8。

d.ConcurrentHashMap 做的改进

ConcurrentHashMap 对 HashMap 在并发下进行了安全的提升，1.7 以前使用的是分段锁，8 以后使用的是对每一个 bucket 使用 synchronized 代码块的方法。

2.常见的垃圾回收算法

引用计数法和可达性分析

a.引用计数的循环引用的情况

这种情况下无法进行垃圾回收，因此可以改用可达性分析方法，通过一系列的 GC Roots 遍历，将无法到达的删除

3.Mysql 的联合索引

联合索引是对多个列进行索引建立

a.索引的底层结构

InnoDB 底层是 B+ 树，在一些其他的引擎中，还有哈希索引、全文索引、R 树索引等。更多内容可以看[数据库内容总结](/Users/y1271752959m/Documents/WorkHardAndFindJob/复习/面试/数据库内容总结.md)

4.100 个人坐座位，第一个人随机坐一个座位，后面的人优先坐自己的座位，只有当自己的座位被占了才会随机坐，问第 100 个人能坐到自己座位的概率（答案50%，不会）

5.段页式管理下 ，CPU取数据要几次访存

2 次把

6.算法题：给出一个数字串的排列，找出下一个比当前数更大的一个排列（不能用next_permutation）

#### 三面
1.场景题：对 HashMap rehash 的时间进行优化
* 我第一次答了：事先预估 capacity，直接申请相应大小
* 我第二次答了：**扩容时仅申请数组但不拷贝，当get命中时顺便拷贝过去**
	* 缺点是什么（可能会生成很多数组）
	* 再优化（不会）

2.手写单例模式

[单例模式](https://github.com/lewiscrow/WorkHardAndFindJob/blob/master/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%9802%EF%BC%9A%20%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F.md)

3.算法题：给出一个转义后的字符串，问原串是什么？（写得不好）


